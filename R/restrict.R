#' Restricted VAR
#'
#' Estimation of a VAR, by imposing zero restrictions manually or by
#' significance.
#'
#' Given an estimated VAR object of class \sQuote{\code{varest}}, a restricted
#' VAR can be obtained by either choosing method \code{ser} or \code{manual}.
#' In the former case, each equation is re-estimated separately as long as
#' there are t-values that are in absolut value below the threshhold value set
#' by the function's argument \code{thresh}. In the latter case, a restriction
#' matrix has to be provided that consists of 0/1 values, thereby selecting the
#' coefficients to be retained in the model.
#'
#' @param x An object of class \sQuote{\code{varest}} generated by
#' \command{VAR()}.
#' @param method A character, choosing the method
#' @param thresh If method \code{ser}: the threshhold value for the
#' t-statistics.
#' @param resmat If method \code{manual}: The restriction matrix.
#' @return A list with class attribute \sQuote{\code{varest}} holding the
#' following elements:\cr
#'
#' \item{varresult}{list of \sQuote{\code{lm}} objects.} \item{datamat}{The
#' data matrix of the endogenous and explanatory variables.} \item{y}{The data
#' matrix of the endogenous variables} \item{type}{A character, specifying the
#' deterministic regressors.} \item{p}{An integer specifying the lag order.}
#' \item{K}{An integer specifying the dimension of the VAR.} \item{obs}{An
#' integer specifying the number of used observations.} \item{totobs}{An
#' integer specifying the total number of observations.}
#' \item{restrictions}{The matrix object containing the zero restrictions
#' provided as argument \code{resmat}.} \item{call}{The \code{call} to
#' \command{VAR()}.}
#' @note Currently, the restricted VAR is estimated by OLS and not by an
#' efficient EGLS-method.
#' @author Bernhard Pfaff
#' @seealso \code{\link{VAR}}
#' @references Hamilton, J. (1994), \emph{Time Series Analysis}, Princeton
#' University Press, Princeton.
#'
#' LÃ¼tkepohl, H. (2006), \emph{New Introduction to Multiple Time Series
#' Analysis}, Springer, New York.
#' @keywords regression
#' @examples
#'
#' data(Canada)
#' var.2c <- VAR(Canada, p = 2, type = "const")
#' ## Restrictions determined by thresh
#' restrict(var.2c, method = "ser")
#' ## Restrictions set manually
#' restrict <- matrix(c(1, 1, 1, 1, 1, 1, 0, 0, 0,
#'                      1, 0, 1, 0, 0, 1, 0, 1, 1,
#'                      0, 0, 1, 1, 0, 1, 0, 0, 1,
#'                      1, 1, 1, 0, 1, 1, 0, 1, 0),
#'                    nrow=4, ncol=9, byrow=TRUE)
#' restrict(var.2c, method = "man", resmat = restrict)
#'
#' @export
"restrict" <-
function (x, method = c("ser", "manual"), thresh = 2, resmat = NULL)
{
    if (!is(x, "varest")) {
        stop("\nPlease provide an object of class 'varest', generated by 'var()'.\n")
    }
    method <- match.arg(method)
    thresh <- abs(thresh)
    K <- x$K
    p <- x$p
    datasub <- x$datamat[, -c(1:K)]
    namesall <- colnames(datasub)
    yendog <- x$datamat[, c(1:K)]
    sample <- x$obs
    ser <- function(x, y) {
        tvals <- abs(coef(summary(x))[, 3])
        datares <- datasub
        if(min(tvals) >= thresh){
          lmres <- x
          datares <- datasub
        } else {
          while (min(tvals) < thresh) {
            if (ncol(datares) > 1) {
              cnames <- colnames(datares)
              datares <- as.data.frame(datares[, -1 * which.min(tvals)])
              colnames(datares) <- cnames[-1 * which.min(tvals)]
              lmres <- lm(y ~ -1 + ., data = datares)
              tvals <- abs(coef(summary(lmres))[, 3])
            } else {
              lmres <- NULL
              datares <- NULL
              break
            }
          }
        }
        return(list(lmres = lmres, datares = datares))

      }
    if (method == "ser") {
        x$restrictions <- matrix(0, nrow = K, ncol = ncol(datasub))
        colnames(x$restrictions) <- namesall
        rownames(x$restrictions) <- colnames(yendog)
        for (i in 1:K) {
            temp <- ser(x$varresult[[i]], yendog[, i])
            if (is.null(temp$lmres)) {
                stop(paste("\nNo significant regressors remaining in equation for",
                  colnames(yendog)[i], ".\n"))
            }
            x$varresult[[i]] <- temp[[1]]
            namessub <- colnames(temp[[2]])
            x$restrictions[i, namesall %in% namessub] <- 1
        }
    }
    else if (method == "manual") {
        resmat <- as.matrix(resmat)
        if (!(nrow(resmat) == K) | !(ncol(resmat) == ncol(datasub))) {
            stop(paste("\n Please provide resmat with dimensions:",
                K, "x", ncol(datasub), "\n"))
        }
        x$restrictions <- resmat
        colnames(x$restrictions) <- namesall
        rownames(x$restrictions) <- colnames(yendog)
        for (i in 1:K) {
            datares <- data.frame(datasub[, which(x$restrictions[i, ] == 1)])
            colnames(datares) <- colnames(datasub)[which(x$restrictions[i, ] == 1)]
            y <- yendog[, i]
            lmres <- lm(y ~ -1 + ., data = datares)
            x$varresult[[i]] <- lmres
        }
    }
    return(x)
}
