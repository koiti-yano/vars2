#' Causality Analysis
#' 
#' Computes the test statistics for Granger- and Instantaneous causality for a
#' VAR(p).
#' 
#' Two causality tests are implemented. The first is a F-type Granger-causality
#' test and the second is a Wald-type test that is characterized by testing for
#' nonzero correlation between the error processes of the cause and effect
#' variables. For both tests the vector of endogenous variables
#' \eqn{\bold{y}_t} is split into two subvectors \eqn{\bold{y}_{1t}} and
#' \eqn{\bold{y}_{2t}} with dimensions \eqn{(K_1 \times 1)} and \eqn{(K_2
#' \times 1)} with \eqn{K = K_1 + K_2}.\cr For the rewritten VAR(p):
#' 
#' \deqn{ [\bold{y}_{1t} , \bold{y}_{2t}] = \sum_{i=1}^p [\bold{\alpha}_{11,
#' i}' , \bold{\alpha}_{12, i}' | \bold{\alpha}_{21, i}' , \bold{\alpha}_{22,
#' i}'][\bold{y}_{1,t-i}, \bold{y}_{2, t-i}] + CD_t + [\bold{u}_{1t},
#' \bold{u}_{2t}] \quad , } the null hypothesis that the subvector
#' \eqn{\bold{y}_{1t}} does not Granger-cause \eqn{\bold{y}_{2t}}, is defined
#' as \eqn{\bold{\alpha}_{21, i} = 0} for \eqn{i = 1, 2, \ldots, p}. The
#' alternative is: \eqn{\exists \; \bold{\alpha}_{21,i} \ne 0} for \eqn{i = 1,
#' 2, \ldots, p}. The test statistic is distributed as \eqn{F(p K_1 K_2, KT -
#' n^*)}, with \eqn{n^*} equal to the total number of parameters in the above
#' VAR(p) (including deterministic regressors).\cr The null hypothesis for
#' instantaneous causality is defined as: \eqn{H_0: C \bold{\sigma} = 0}, where
#' \eqn{C} is a \eqn{(N \times K(K + 1)/2)} matrix of rank \eqn{N} selecting
#' the relevant co-variances of \eqn{\bold{u}_{1t}} and \eqn{\bold{u}_{2t}};
#' \eqn{\bold{\sigma} = vech(\Sigma_u)}. The Wald statistic is defined as:
#' \deqn{ \lambda_W = T \tilde{\bold{\sigma}}'C'[2 C D_{K}^{+}(\tilde{\Sigma}_u
#' \otimes \tilde{\Sigma}_u) D_{K}^{+'} C']^{-1} C \tilde{\bold{\sigma}} \quad
#' , } hereby assigning the Moore-Penrose inverse of the duplication matrix
#' \eqn{D_K} with \eqn{D_{K}^{+}} and \eqn{\tilde{\Sigma}_u =
#' \frac{1}{T}\sum_{t=1}^T \hat{\bold{u}}_t \hat{\bold{u}}_t'}. The duplication
#' matrix \eqn{D_K} has dimension \eqn{(K^2 \times \frac{1}{2}K(K + 1))} and is
#' defined such that for any symmetric \eqn{(K \times K)} matrix A, \eqn{vec(A)
#' = D_K vech(A)} holds. The test statistic \eqn{\lambda_W} is asymptotically
#' distributed as \eqn{\chi^2(N)}.
#' 
#' Fot the Granger causality test, a robust covariance-matrix estimator can be
#' used in case of heteroskedasticity through argument \code{vcov.} It can be
#' either a pre-computed matrix or a function for extracting the covariance
#' matrix. See \code{\link[sandwich]{vcovHC}} from package \pkg{sandwich} for
#' further details.
#' 
#' A wild bootstrap computation (imposing the restricted model as null) of the
#' p values is available through argument \code{boot} and \code{boot.runs}
#' following Hafner and Herwartz (2009).
#' 
#' @param x Object of class \sQuote{\code{varest}}; generated by
#' \command{VAR()}.
#' @param cause A character vector of the cause variable(s). If not set, then
#' the variable in the first column of \code{x$y} is used as cause variable and
#' a warning is printed.
#' @param vcov. a specification of the covariance matrix of the estimated
#' coefficients. This can be specified as a matrix or as a function yielding a
#' matrix when applied to \code{x}.
#' @param boot Logical. Whether a wild bootstrap procedure should be used to
#' compute the critical values. Default is no
#' @param boot.runs Number of bootstrap replications if boot=TRUE
#' @return A list with elements of class \sQuote{\code{htest}}:\cr
#' 
#' \item{Granger}{The result of the Granger-causality test.} \item{Instant}{The
#' result of the instantaneous causality test.}
#' @note The Moore-Penrose inverse matrix is computed with the function
#' \code{\link[MASS]{ginv}} contained in the package \sQuote{\code{MASS}}.\cr
#' The Granger-causality test is problematic if some of the variables are
#' nonstationary. In that case the usual asymptotic distribution of the test
#' statistic may not be valid under the null hypothesis.
#' @author Bernhard Pfaff
#' @seealso \code{\link{VAR}}
#' @references Granger, C. W. J. (1969), Investigating causal relations by
#' econometric models and cross-spectral methods, \emph{Econometrica},
#' \bold{37}: 424-438.
#' 
#' Hafner, C. M. and Herwartz, H. (2009) Testing for linear vector
#' autoregressive dynamics under multivariate generalized autoregressive
#' heteroskedasticity, \emph{Statistica Neerlandica}, \bold{63}: 294-323
#' 
#' Hamilton, J. (1994), \emph{Time Series Analysis}, Princeton University
#' Press, Princeton.
#' 
#' LÃ¼tkepohl, H. (2006), \emph{New Introduction to Multiple Time Series
#' Analysis}, Springer, New York.
#' 
#' Venables, W. N. and B. D. Ripley (2002), \emph{Modern Applied Statistics
#' with S}, 4th edition, Springer, New York.
#' 
#' Zeileis, A. (2006) Object-Oriented Computation of Sandwich Estimators
#' \emph{Journal of Statistical Software}, \bold{16}, 1-16
#' @keywords regression
#' @examples
#' \dontrun{
#' data(Canada)
#' var.2c <- VAR(Canada, p = 2, type = "const")
#' causality(var.2c, cause = "e")
#' 
#' #use a robust HC variance-covariance matrix for the Granger test:
#' causality(var.2c, cause = "e", vcov.=vcovHC(var.2c))
#' 
#' #use a wild-bootstrap procedure to for the Granger test
#' causality(var.2c, cause = "e", boot=TRUE, boot.runs=1000)}
#' 
#' @export causality
causality <-
function(x, cause = NULL, vcov.=NULL, boot=FALSE, boot.runs=100){
  if(!is(x, "varest")){
    stop("\nPlease provide an object of class 'varest', generated by 'var()'.\n")
  }
  K <- x$K
  p <- x$p
  obs <- x$obs
  type <- x$type
  obj.name <- deparse(substitute(x))
  y <- x$y
  y.names <- colnames(x$y)
  if(is.null(cause)){
    cause <- y.names[1]
    warning("\nArgument 'cause' has not been specified;\nusing first variable in 'x$y' (", cause, ") as cause variable.\n")
  } else {
    if(!all(cause%in%y.names)) stop("Argument cause does not match variables names.\n")
  }
  y1.names <- subset(y.names, subset = y.names %in% cause)
  y2.names <- subset(y.names, subset = !(y.names %in% cause))
  Z <- x$datamat[, -c(1 : K)]
  xMlm<-toMlm(x)
  PI <- coef(xMlm)
  PI.vec <- as.vector(PI)

  ###Restriction matrix R for Granger causality
  #build matrix of same size as coef matrix indicating which to be restricted
  R2<-matrix(0, ncol=ncol(PI), nrow=nrow(PI))
  g<-which(gsub("\\.l\\d+", "", rownames(PI))%in%cause) #select cause regressors
  j<-which(colnames(PI)%in%cause) #select cause regressand
  R2[g,-j]<-1	#select coef to be tested
  #If the model already has restriction, overlay with the new ones
  if (!is.null(x$restrictions)) {
      xr <- t(x$restrictions)
      xr <- abs(xr - 1)
      # match positions of variables
      rownames(xr)[rownames(xr) == "const"] <- "(Intercept)"
      xr <- xr[rownames(PI), colnames(PI)]
      # overlay
      xr <- xr + R2
      xr[xr == 2] <- 1
      R2 <- xr
  }
  w<-which(as.vector(R2)!=0)
  #build corresponding matrix as coef are not vectorized
  N <- length(w)
  R<-matrix(0, ncol=ncol(PI)*nrow(PI), nrow=N) #matrix of restrictions
  for(i in 1:N) R[i,w[i]]<-1

  ##
  ## Granger-causality
  ##
  if (is.null(vcov.)) {
      sigma.pi  <- vcov(xMlm)
  } else if (is.function(vcov.)) {
      sigma.pi  <- vcov.(xMlm)
  } else {
      sigma.pi  <- vcov.
  }
  df1 <- p * length(y1.names) * length(y2.names)
  df2 <- K * obs - length(PI)#K^2 * p - detcoeff
  STATISTIC <- t(R %*% PI.vec) %*% solve(R %*% sigma.pi %*% t(R)) %*% R %*% PI.vec / N

  ###bootstrap procedure
  if(boot){
    ###Restricted model: estimation under null of Granger non-causality
    co.names<-Bcoef(x)
    #needs to rebuild another restriction matrix for restrict(), as disposition of coef is different
    k<-which(gsub("\\.l\\d+", "", colnames(co.names))%in%cause) #select cause regressors
    l<-which(rownames(co.names)%in%cause) #select cause regressand
    R2inv<-matrix(1, ncol=nrow(PI), nrow=ncol(PI)) #exact inverse steps as R2
    R2inv[-l,k]<-0	#select coef to be tested
    #If the model already has restriction, overlay with the new ones
    if (!is.null(x$restrictions)) {
        xr <- x$restrictions
        # match positions of variables
        xr <- xr[rownames(co.names), colnames(co.names)]
        # overlay
        R2inv <- xr * R2inv
    }
    xres<-restrict(x, method = "man", resmat = R2inv)
    pred<-sapply(xres$varresult,predict)
    res<-residuals(xres)

    #bootstrap function for homo case: use more efficient low-level, as XX-1 already computed
    if(is.null(vcov.)){
        if (is.null(x$restrictions)) { #haven't figured out how to adjust these lines to account for existing restrictions
      Zmlm<-model.matrix(xMlm)
      cross<-crossprod(Zmlm)
      inside<-solve(R %*% sigma.pi %*% t(R))
      boot.fun<-function(x=1){
	Ynew<-pred+res*rnorm(n=obs, mean=0, sd=x)
	PI.boot<-solve(cross, crossprod(Zmlm,Ynew)) #this could be made more efficent: compute only interest coefs,
	PI.boot.vec<-as.vector(PI.boot)
	t(R %*% PI.boot.vec) %*% inside %*% (R %*% PI.boot.vec) / N
      }
        } else { #if restrictions already exist; reestimate models (slower), use vcov by default
            xtmp <- x
            boot.fun <- function(x = 1) {
                xtmp$datamat[,1:K] <- pred + res * rnorm(n = obs, mean = 0, sd = x)
                xMlm.boot <- toMlm(xtmp)
                sigma.pi.boot  <- vcov(xMlm.boot)
                PI.boot.vec <- as.vector(coef(xMlm.boot))
                t(R %*% PI.boot.vec) %*% solve(R %*% sigma.pi.boot %*% t(R)) %*% R %*% PI.boot.vec / N
            }
        }
    } else {
    #two next lines as needed as x<-freeny.x; mylm<-lm(freeny.y~x); rm(x);update(mylm) #does not work
        xtmp <- x
      # X<-x$datamat
      # if(x$type%in%c("const", "both")) X<-X[, -grep("const", colnames(X))]
      boot.fun<-function(x=1){
          xtmp$datamat[,1:K]<-pred+res*rnorm(n=obs, sd=x, mean=0) #workaround as calling it ynew and putting in update() fails
	# xMlm.boot<-update(xMlm, .~.) #replace with the row below to account for possible restrictions
          xMlm.boot <- toMlm(xtmp)
          if (is.function(vcov.)) {
              sigma.pi.boot <- vcov.(xMlm.boot)
          } else {
              sigma.pi.boot <- vcov.
              warning("vcov. should be function, not an object, when used with boot=TRUE")
          }
	PI.boot.vec <- as.vector(coef(xMlm.boot))
	t(R %*% PI.boot.vec) %*% solve(R %*% sigma.pi.boot %*% t(R)) %*% R %*% PI.boot.vec / N
      }
    }
    res.rep<-replicate(boot.runs, boot.fun(x=1))
    pval<-mean(res.rep>as.numeric(STATISTIC))
  }
  names(STATISTIC) <- "F-Test"
  if(!boot){
    PARAMETER1 <- df1
    PARAMETER2 <- df2
    names(PARAMETER1) <- "df1"
    names(PARAMETER2) <- "df2"
    PVAL <- 1 - pf(STATISTIC, PARAMETER1, PARAMETER2)
    PARAM<-c(PARAMETER1, PARAMETER2)
  } else {
    PARAMETER1 <- boot.runs
    names(PARAMETER1) <- "boot.runs"
    PVAL <- pval
    PARAM<-PARAMETER1
  }
  METHOD <- paste("Granger causality H0:", paste(y1.names, collapse=" "), "do not Granger-cause", paste(y2.names, collapse=" "))
  result1 <- list(statistic = STATISTIC, parameter = PARAM, p.value = PVAL, method = METHOD, data.name = paste("VAR object", obj.name))
  class(result1) <- "htest"
  ##
  ## Instantaneous Causality
  ##
  sigma.u <- crossprod(resid(x)) / (obs - ncol(Z))
  colnames(sigma.u) <- y.names
  rownames(sigma.u) <- y.names
  select <- sigma.u[rownames(sigma.u) %in% y2.names, colnames(sigma.u) %in% y1.names ]
  sig.vech <- sigma.u[lower.tri(sigma.u, diag = TRUE)]
  index <- which(sig.vech %in% select)
  N <- length(index)
  Cmat <- matrix(0, nrow = N, ncol = length(sig.vech))
  for(i in 1 : N){
    Cmat[i, index[i]] <- 1
  }
  Dmat <- .duplicate(K)
  Dinv <- MASS::ginv(Dmat)
  lambda.w <- obs %*% t(sig.vech) %*% t(Cmat) %*% solve(2 * Cmat %*% Dinv %*% kronecker(sigma.u, sigma.u) %*% t(Dinv) %*% t(Cmat)) %*% Cmat %*% sig.vech
  STATISTIC <- lambda.w
  names(STATISTIC) <- "Chi-squared"
  PARAMETER <- N
  names(PARAMETER) <- "df"
  PVAL <- 1 - pchisq(STATISTIC, PARAMETER)
  METHOD <- paste("H0: No instantaneous causality between:", paste(y1.names, collapse=" "), "and", paste(y2.names, collapse=" "))
  result2 <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = paste("VAR object", obj.name))
  class(result2) <- "htest"
  result2
  return(list(Granger = result1, Instant = result2))
}
